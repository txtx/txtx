export const metadata = {
    title: "Stacks Blockchain (beta) Signers",
    description: "Signers for Stacks Blockchain (beta)",
};

# Stacks Blockchain (beta) Signers {{ id: "stacks-signers" }}



## mnemonic {{ tag: 'signer' }}

The `mnemonic` signer can be used to synchronously sign a transaction.

### Inputs

<Properties>


  <Property name="mnemonic" type="">
    The mnemonic phrase used to generate the secret key.
  </Property>


  <Property name="derivation_path" type="">
    The derivation path used to generate the secret key.
  </Property>


  <Property name="is_encrypted" type="">
    Coming soon
  </Property>


  <Property name="password" type="">
    Coming soon
  </Property>


</Properties>

### Outputs

<Note>

When the `mnemonic` action is successfully executed, the following outputs are attached to the action

</Note>

<Properties>


  <Property name="public_key">
    The public key of the account generated from the secret key.
  </Property>


</Properties>

<CodeGroup title="Example using mnemonic">


```hcl {{ title: 'main.tx' }}
signer "bob" "stacks::secret_key" {
    mnemonic = "board list obtain sugar hour worth raven scout denial thunder horse logic fury scorpion fold genuine phrase wealth news aim below celery when cabin"
    derivation_path = "m/44'/5757'/0'/0/0"
}

```


```json {{ title: 'main.json' }}
// Coming soon
```

```yaml {{ title: 'main.yaml' }}
# Coming soon
```

</CodeGroup>

---


## connect {{ tag: 'signer' }}

The `connect` signer will route the transaction signing process through [Stacks.js connect](https://www.hiro.so/stacks-js).
This allows a Runbook operator to sign the transaction with the browser signer of their choice.

### Inputs

<Properties>


  <Property name="expected_address" type="">
    The Stacks address that is expected to connect to the Runbook execution. Omitting this field will allow any address to be used for this signer.
  </Property>


</Properties>

### Outputs

<Note>

When the `connect` action is successfully executed, the following outputs are attached to the action

</Note>

<Properties>


  <Property name="public_key">
    The public key of the connected signer.
  </Property>


</Properties>

<CodeGroup title="Example using connect">


```hcl {{ title: 'main.tx' }}
signer "alice" "stacks::connect" {
    expected_address = "ST12886CEM87N4TP9CGV91VWJ8FXVX57R6AG1AXS4"
}

```


```json {{ title: 'main.json' }}
// Coming soon
```

```yaml {{ title: 'main.yaml' }}
# Coming soon
```

</CodeGroup>

---


## multisig {{ tag: 'signer' }}

The `multisig` signer creates an ordered, `n` of `n` multisig.
Each of the specified signers can be any other supported signer type, and will be prompted to sign in the appropriate order.

### Inputs

<Properties>


  <Property name="signers" type="">
    A list of signers that make up the multisig.
  </Property>


  <Property name="expected_address" type="">
    The multisig address that is expected to be created from combining the public keys of all parties. Omitting this field will allow any address to be used for this signer.
  </Property>


</Properties>

### Outputs

<Note>

When the `multisig` action is successfully executed, the following outputs are attached to the action

</Note>

<Properties>


  <Property name="public_key">
    The public key of the generated multisig signer.
  </Property>


  <Property name="signers">
    The list of signers that make up the multisig.
  </Property>


</Properties>

<CodeGroup title="Example using multisig">


```hcl {{ title: 'main.tx' }}
signer "alice" "stacks::connect" {
    expected_address = "ST2JHG361ZXG51QTKY2NQCVBPPRRE2KZB1HR05NNC"
}

signer "bob" "stacks::connect" {
    expected_address = "ST2NEB84ASENDXKYGJPQW86YXQCEFEX2ZQPG87ND"
}

signer "alice_and_bob" "stacks::multisig" {
    signers = [signer.alice, signer.bob]
}

```


```json {{ title: 'main.json' }}
// Coming soon
```

```yaml {{ title: 'main.yaml' }}
# Coming soon
```

</CodeGroup>

---

