// Runbook deploy-counter.tx
action "counter_deployment" "evm::deploy_contract" {
    path = "./Hello.sol"
    signer = wallet.alice
    chain_id = each.evm_chain_id
    network_id = each.evm_network_id
}

txtx run deploy-counter --inputs chain_id="arbitrum",chain_id="polygon"


addon "evm" {
    batch = [{
        chain_id: "sepolia"
    }]
}

addon "evm" {
    chains = [
        "sepolia"
    ]
}


action ""



// How are we deploying to Polygon, Arbitrum, etc.
// chain_id, network_id

// state is saved as HashMap<(hash of [runbook, inputs]), ExecutionStates> 


action "counter_deployment" "evm::deploy_contract" {
    for_each = input.supported_chains
    path = "./Hello.sol"
    chain_id = each.evm_chain_id
    network_id = each.evm_network_id
}

Runbook Name 
    > Polygon {input_name}
        > execution 1
        > execution 2
        


input "chains_ids" {
    supported_chains = [
        "polygon",
        "arbitrum"
    ]
}




// https://github.com/txtx/txtx/issues/96

// iterator "matches_data" {
//   source "values" {
//     values = [1, 2, 3, 4, 5, 6, 7, 8, 8, 10]
//   }
//   zip "signers" {
//     values = [
//       "cycle puppy glare enroll cost improve round trend wrist mushroom scorpion tower claim oppose clever elephant dinosaur eight problem before frozen dune wagon high",
//       "board list obtain sugar hour worth raven scout denial thunder horse logic fury scorpion fold genuine phrase wealth news aim below celery when cabin"
//     ]
//     mode = "round-robin"
//   }
// }

// pipeline "close_matches" {
//   mode = "parallel" | "sequence"
//   runbook = "beefy_swap::close_match"
//   override "input.match_id" {
//     input "value" {
//       source = iterator.matches_data.values
//     }
//   }
//   override "wallet.alice" {
//     input "mnemonic" {
//       source = iterator.matches_data.signers
//     }
//   }
// }